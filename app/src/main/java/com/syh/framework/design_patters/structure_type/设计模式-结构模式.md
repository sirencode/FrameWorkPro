# 设计模式-结构模式

## 代理模式

### 定义

为其他对象提供一种代理以控制这个对象的访问。

### 角色

* Subject（抽象主题类）：接口或者抽象类，声明真实主题与代理的共同接口方法。
* RealSubject（真实主题类）：也叫做被代理类或被委托类，定义了代理所表示的真实对象，负责具体业务逻辑的执行，客户端可以通过代理类间接的调用真实主题类的方法。
* Proxy（代理类）：也叫委托类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。
* Client（客户端类）：使用代理模式的地方。

### 场景

当一个对象不能或者不想直接访问另一个对象时，可以通过一个代理对象来间接访问。为保证客户端使用的透明性，委托对象和代理对象要实现同样的接口。

### 优缺点

优点： 代理作为调用者和真实主题的中间层,降低了模块间和系统的耦合性。可以以一个小对象代理一个大对象,达到优化系统提高运行速度的目的。代理对象能够控制调用者的访问权限，起到了保护真实主题的作用。

缺点：由于在调用者和真实主题之间增加了代理对象，因此可能会造成请求的处理速度变慢。实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。

### Android中使用

ActivityManagerProxy，WMS等系统服务的代理。

## 组合模式

### 定义

将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

### 角色

* Component 抽象构件角色：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。
* Leaf 叶子构件：叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。
* Composite 树枝构件：树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。

### 场景

维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。从一个整体中能够独立出部分模块或功能的场景。

## 适配器模式

### 定义

将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

### 角色

* Adapter(适配器接口):即目标角色，定义把其他类转换为何种接口，也就是我们期望的接口。
* Adaptee(被适配角色):即源角色，一般是已存在的类，需要适配新的接口。
* ConcreteAdapter(具体适配器):实现适配器接口，把源角色接口转换为目标角色期望的接口。

### 场景

当想使用一个已经存在的类，但它的接口不符合需求时。当想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。

### 优缺点

优点：提高了类的复用性，提高了灵活性，符合开放封闭原则。

缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。明明调用A接口，却被适配成B接口。

## 装饰者模式

### 定义

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。

### 角色

* Component（抽象组件）：接口或者抽象类，被装饰的最原始的对象。具体组件与抽象装饰角色的父类。
* ConcreteComponent（具体组件）：实现抽象组件的接口。
* Decorator（抽象装饰角色）：一般是抽象类，抽象组件的子类，同时持有一个被装饰者的引用，用来调用被装饰者的方法;同时可以给被装饰者增加新的职责。
* ConcreteDecorator（具体装饰类）：抽象装饰角色的具体实现。

### 场景

需要扩展一个类的功能，或给一个类增加附加功能时，需要动态的给一个对象增加功能，这些功能可以再动态的撤销，当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。

### 优缺点

优点：采用组合的方式，可以动态的扩展功能，同时也可以在运行时选择不同的装饰器，来实现不同的功能。有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。被装饰者与装饰者解偶，被装饰者可以不知道装饰者的存在，同时新增功能时原有代码也无需改变，符合开放封闭原则。

缺点：装饰层过多的话，维护起来比较困难。如果要修改抽象组件这个基类的话，后面的一些子类可能也需跟着修改，较容易出错。

### Android中使用

Context类在这里就充当了抽象组件的角色，ContextImpl类则是具体的组件，而ContextWrapper就是具体的装饰角色，通过扩展ContextWrapper增加不同的功能，就形成了Activity、Service等子类。


## 享元模式

### 定义

使用共享对象可有效地支持大量的细粒度的对象.

### 角色

* Flyweight(抽象享元角色)：接口或抽象类，可以同时定义出对象的外部状态和内部状态的接口或实现。
* ConcreteFlyweight（具体享元角色）：实现抽象享元角色中定义的业务。
* UnsharedConcreteFlyweight（不可共享的享元角色）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。该对象一般不会出现在享元工厂中。
* FlyweightFactory（享元工厂）：管理对象池和创建享元对象。

### 场景

系统存在大量相似或相同的对象，外部状态相同类似情况下，需要缓冲池。

### 优缺点

优点：	大大减少了系统创建的对象，降低了程序内存的使用。

缺点：将对象分为内部状态和外部状态两部分，导致系统变复杂，逻辑也更复杂。将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

### Java中使用

Java中的String。如果字符串常量池中有此字符则直接返回，否则先在字符串常量池中创建字符串。


## 外观模式

### 定义

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。

### 角色

* Facade(外观角色):对外的统一入口。
* Complex System(复杂系统)：一般由多个子系统构成，负责具体功能的实现。

### 场景

为一个复杂的子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化(sdk封装)。使用外观模式可以将一个子系统和使用它的客户端以及其它的子系统分离开来，这就提高了子系统的独立性和可移植性。在构建一个层次化结构的时候，可以使用外观模式定义每一个层次对外交互的接口。这样，层与层之间只需要通过外观进行通信，从而简化层与层之间的依赖关系。

### 优缺点

优点：降低了客户端与子系统类的耦合度，实现了子系统与客户之间的松耦合关系。外观类对子系统的接口封装，使得系统更易于使用。提高灵活性，不管子系统如何变化，只要不影响门面对象，就可以自由修改。

缺点：增加新的子系统可能需要修改外观类的源代码，违背了“开闭原则”。所有子系统的功能都通过一个接口来提供，这个接口可能会变得很复杂。

### Android中使用

外观模式在Android中应用也非常广泛，比如Context类，里面封装了很多方法，还是以startActivity()方法为例。实际上startActivity()是通过ActivityManagerService来实现的，ActivityManagerService我们应该都有耳闻，但是实际开发中一般都用不到，通过封装的方式，Context类隐藏了这些细节，我们只要简单调个方法就可以启动一个新的Activity。

## 桥接模式

### 定义 

将抽象部分与实现部分分离，使它们都可以独立的变化。

### 角色

* Abstraction(抽象化角色)：一般是抽象类，定义该角色的行为，同时保存一个对实现化角色的引用。
* Implementor(实现化角色)：接口或者抽象类，定义角色必需的行为和属性。
* ConcreteImplementorA、ConcreteImplementorB(具体实现化角色):实现角色的具体行为。

### 场景

一个类存在两个或以上的独立维度的变化，且这些维度都需要进行拓展。不希望使用继承或因为多层次继承导致类的个数急剧增加时。如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，可以通过桥接模式使他们在抽象层建立一个关联关系。

### 优缺点

优点：分离了抽象与实现。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。良好的扩展性。抽象部分和实现部分都可以分别独立扩展，不会相互影响。

缺点：增加了系统的复杂性。不容易设计，抽象与实现的分离要设计得好比较有难度。

### Android中使用

1 AbsListView跟ListAdapter之间就是一个桥接模式。

2 Window与WindowManager之间也是桥接模式。

