# 设计模式-行为模式

## 策略模式

### 定义

定义一系列的算法，把每一个算法封装起来,并且使它们可相互替换。策略模式模式使得算法可独立于使用它的客户而独立变化。策略模式提供了一组算法给客户端调用，使得客户端能够根据不同的条件来选择不同的策略来解决不同的问题。

### 角色

* Stragety(抽象策略类)：抽象类或接口，提供具体策略类需要实现的接口。
* ConcreteStragetyA、ConcreteStragetyB（具体策略类）：具体的策略实现，封装了相关的算法实现。
* Context（环境类）：用来操作策略的上下文环境。

### 场景

* 同一个问题具有不同算法时，即仅仅是具体的实现细节不同时，如各种排序算法等等。
* 对客户隐藏具体策略(算法)的实现细节，彼此完全独立；提高算法的保密性与安全性。
* 一个类拥有很多行为，而又需要使用if-else或者switch语句来选择具体行为时。使用策略模式把这些行为独立到具体的策略类中，可以避免多重选择的结构。

### 优缺点

优点：策略类可以互相替换。耦合度低，方便扩展。避免使用多重条件选择语句（if-else或者switch）。

缺点：策略的增多会导致子类的也会变多。

### Android 中使用

1 ListView时都需要设置一个Adapter，而这个Adapter根据我们实际的需求可以用ArrayAdapter、SimpleAdapter等等，这里就运用到策略模式。

2 动画的Interpolator的设置。

## 状态模式

### 定义

在不同的状态下，对同一行为有不同的响应。状态模式把对象的行为包装在不同的状态中，每一个状态的对象都有一个相同的抽象状态基类，并实现基类对应的方法。这样当一个对象的状态发生改变时，其行为也会随之改变。

### 角色

* State：抽象状态类或者接口，其中的方法表示对应状态下的行为。
* StateA、StateB：State的具体实现类，以实现对应状态下具体的行为。
* Context：维护当前对象所对应的状态。

### 场景

当一个对象的行为受其对应的状态的影响时。例如：手机的飞行模式打开和关闭是两个状态，在关闭飞行模式时可以打电话、发短信，打开飞行模式时，虽然打电话和发短信的功能存在，但却无法正常使用。

### 优缺点

优点：避免了过多的条件语句，使得结构更清晰，提高代码的可维护性。每一个状态都是一个子类，方便增加修改状态。状态被放置到类的内部，外部调用者不需要知道内部实现。

缺点：导致子类过多。

### Android中使用

WifiDriverState，在不同的状态下对于扫描Wifi这个请求的处理是完全不一样的。在初始状态下扫描请求被直接忽略，在驱动加载中状态下Wifi扫描请求被添加到延迟处理的消息列表，在驱动加载完成状态下扫描Wifi的请求直接被处理。

## 责任链模式

### 定义

一个请求沿着一条“链”传递，直到该“链”上的某个处理者处理它为止。一个请求通过链的头部，一直往下传递到链上的每一个结点，直到有某个结点对这个请求做出处理为止，这就是责任链模式。

### 角色

* Handler（抽象处理者）：抽象类或者接口,定义处理请求的方法以及持有下一个Handler的引用.
* ConcreteHandler1,ConcreteHandler2（具体处理者）：实现抽象处理类,对请求进行处理,如果不处理则转发给下一个处理者.

### 场景

多个对象处理同一请求时，但是具体由哪个对象去处理需要运行时做判断。具体处理者不明确的情况下，向这组对象提交了一个请求。

### 优缺点

优点：	代码的解耦，请求者与处理者的隔离分开。易于扩展，新增处理往链上加节点即可。

缺点：链过长影响性能，有可能遍历完都找不到。

### Android中使用

1 Android中的事件分发机制就是类似于责任链模式。有序广播。

2 OKhttp中对请求的处理也是用到了责任链模式。

## 观察者模式

### 定义

定义对象间的一种一个对多的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新。

### 角色

* Subject（抽象主题）：又叫抽象被观察者，把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
* ConcreteSubject（具体主题）：又叫具体被观察者，将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。
* Observer (抽象观察者):为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
* ConcrereObserver（具体观察者）：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态。

### 场景

当一个对象的改变需要通知其它对象改变时，而且它不知道具体有多少个对象有待改变时。

### 优缺点

优点：	解除观察者与主题之间的耦合。让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。	易于扩展，对同一主题新增观察者时无需修改原有代码。

缺点：抽象主题仍然依赖抽象观察者。	可能会引起多余的数据通知。消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。

### Android中使用

1 控件中Listener监听方式

2 Adapter的notifyDataSetChanged()方法

3 BroadcastReceiver

## 模板模式

### 定义

定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。

### 角色

* AbstractClass（抽象类）：定义了一整套算法框架。
* ConcreteClass（具体实现类）：具体实现类，根据需要去实现抽象类中的方法。

### 场景

一次性实现算法的执行顺序和固定不变部分，可变部分则交由子类来实现。多个子类中拥有相同的行为时，可以将其抽取出来放在父类中，避免重复的代码。

### 优缺点

优点：提高代码复用性，去除子类中的重复代码。提高扩展性，不同实现细节放到不同子类中，易于增加新行为。

缺点：每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。

### Android中使用

Android中View的draw方法就是使用了模板方法模式：

* 1 绘制view背景 
* 2 如果有需要，就保存图层 
* 3 绘制view内容 
* 4 绘制子View 
* 5 如果有必要，绘制渐变框和恢复图层 
* 6 绘制装饰（滑动条等）

## 迭代器模式

### 定义

提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。

### 角色

* Iterator（迭代器接口）：负责定义、访问和遍历元素的接口。
* ConcreteIterator（具体迭代器类）:实现迭代器接口。
* Aggregate（容器接口）：定义容器的基本功能以及提供创建迭代器的接口。
* ConcreteAggregate（具体容器类）：实现容器接口中的功能。

### 场景

遍历一个容器对象时。

### 优缺点

优点：	可以支持以不同的方式去遍历容器对象，如顺序遍历，逆序遍历等等。

缺点：	会产生多余的对象，消耗内存。会增多类文件。遍历过程是一个单向且不可逆的遍历。遍历过程需要注意容器是否改变，若期间改变了，可能会抛出异常。

### Android中使用

1 Cursor

## 备忘录模式

### 定义

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态。

### 角色

* Originator（发起人角色）：负责创建一个备忘录（Memoto），能够记录内部状态，以及恢复原来记录的状态。并且能够决定哪些状态是需要备忘的。
* Memoto（备忘录角色）：将发起人（Originator）对象的内部状态存储起来；并且可以防止发起人（Originator）之外的对象访问备忘录（Memoto）。
* Caretaker（负责人角色）：负责保存备忘录（Memoto），不能对备忘录（Memoto）的内容进行操作和访问，只能将备忘录传递给其他对象。

### 场景

需要保存对象的某一时刻的状态时

### 优缺点

优点：	能够让状态回滚到某一时刻的状态。实现了状态保存对象的封装，用户无需关心其实现细节。

缺点：	要保存的对象如果成员变量过多的话，资源消耗也会相应增多。

### Android中使用

Activity状态保存，onSaveInstanceState和onRestoreInstanceState。

## 访问者模式

### 定义

封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

### 角色

* Visitor（抽象访问者）：接口或者抽象类，为每一个元素（Element）声明一个访问的方法。
* ConcreteVisitor（具体访问者）：实现抽象访问者中的方法，即对每一个元素都有其具体的访问行为。
* Element（抽象元素）：接口或者抽象类，定义一个accept方法，能够接受访问者（Visitor）的访问。
* ConcreteElementA、ConcreteElementB（具体元素）：实现抽象元素中的accept方法，通常是调用访问者提供的访问该元素的方法。
* Client（客户端类）：即要使用访问者模式的地方。

### 场景

对象结构比较稳定，很少改变，但是经常需要在此对象结构上定义新的操作行为时。需要对一个对象结构中的对象进行很多不同的并且不相关的操作,它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。

### 优缺点

优点：各种角色各司其职，符合单一职责原则。良好的扩展性，新增访问操作变得简单。数据操作和数据结构的解耦。

缺点：新增具体元素困难。违反了依赖倒置原则。具体元素修改的成本太大。

## 中介者模式

### 说明

用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。中介者模式也称为调解者模式或者调停者模式。引入中介者，将网状结构转化成星型结构，可以降低程序的复杂性，并且可以减少各个对象之间的耦合。

### 角色介绍

* Mediator(抽象中介者角色):抽象类或者接口,定义统一的接口，用于各同事角色之间的通信。
* ConcreteMediator(具体中介者角色):继承或者实现了抽象中介者，实现了父类定义的方法,协调各个具体同事进行通信。
* Colleague(抽象同事角色):抽象类或者接口,定义统一的接口，它只知道中介者而不知道其他同事对象。
* ConcreteColleague(具体同事角色):继承或者实现了抽象同事角色，每个具体同事类都知道自己本身的行为，其他的行为只能通过中介者去进行。

### 优缺点

优点：

* 降低类的关系复杂度，将多对多转化成一对多，实现解耦。
* 符合迪米特原则，依赖的类最少。

缺点：

* 同事类越多，中介者的逻辑就越复杂，会变得越难维护。
* 如果本来类的依赖关系不复杂，但是使用了中介者会使原来不复杂的逻辑变得复杂。因此需要根据实际情况去考虑，不要滥用中介者。

## 解释器模式

### 定义

解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语句中的句子。

### 角色

* 抽象表达式角色(Expression)：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称作解释操作。
* 终结符表达式角色(Terminal Expression)：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面的R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
* 非终结表达式角色(Nonterminal Expression)：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。
* 环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息都需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就够了。

## 命令模式

### 定义

将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录日志，可以提供命令的撤销和恢复功能。我们遇到最常见的命令模式就是关机操作了，我们只需点击一下关机按钮就可以了，至于计算机是如何关机的，我们不需要关心其实现细节。

### 角色

* Command：接口或者抽象类，定义要执行的命令。
* ConcreteCommand（具体命令角色）：命令角色的具体实现，通常会持有接收者，并调用接收者来处理命令。
* Invoker（调用者角色）：负责调用命令对象执行请求，通常会持有命令对象（可以持有多个命令对象）。Invoker是Client真正触发命令并要求命令执行相应操作的地方（使用命令对象的入口）。
* Receiver（接收者角色）：是真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
* Client（客户端角色）：Client可以创建具体的命令对象，并且设置命令对象的接收者。

### 优缺点

优点：调用者与接受者之间的解藕。易于扩展，扩展命令只需新增具体命令类即可，符合开放封闭原则。

缺点：过多的命令会造成过多的类。

### Android中应用

1 Thread：Thread的start()方法即命令的调用者，同时Thread的内部会调用Runnable的run()，这里Thread又充当了具体的命令角色，最后的Runnable则是接受者了，负责最后的功能处理。

2 Handler: 接受者：Handler，执行消息的处理操作。调用者：Looper，调用消息的的处理方法。命令角色：Message，消息类。
















